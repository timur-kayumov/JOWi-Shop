бзор архитектуры решения

(Здесь описывается техническая архитектура, чтобы подтвердить, что она соответствует требованиям продукта.)

Клиентские приложения:

Desktop POS: Настольное приложение на Electron + React. Бандлирование через Vite (для быстрого запуска и HMR при разработке). Код POS написан на TypeScript, UI-слои разделены на компоненты из общего набора (см. ниже). Electron позволяет доступ к файловой системе (для хранения SQLite базы) и к нативным функциям OS (например, управление печатью на локальном принтере).

Web Admin (Back-Office): Веб-приложение для администратора и менеджеров, основанное на Next.js (с использованием App Router для сегментации маршрутов и потенциала SSR/SSG, хотя в основном будет CSR для админки). React + TypeScript.

Shared UI Library: Создаётся отдельный пакет @jowi/ui – набор React-компонентов и стилей, используемый и в POS, и в веб-админке для единообразия. В нём будут реализованы общие компоненты интерфейса (кнопки, таблицы, модальные окна и т.п.) согласно дизайн-гайдам (см. UI/UX раздел).

Стили и темы: Используем Tailwind CSS для быстрой и единообразной стилизации. Настроены CSS Variables для цветовых тем (light/dark), чтобы переключение тем влияло на набор переменных (например, background, text color, primary color). Две темы (светлая и тёмная) должны поддерживаться с самого начала.

Radix UI Primitives: используем Radix (https://www.radix-ui.com/) для доступных сниппетов UI (диалоги, поповеры, листбоксы и пр.), чтобы обеспечить хорошую UX и доступность. Компоненты ShadCN/UI оборачивают Radix, предлагая готовые стилизованные блоки на Tailwind – это ускорит разработку.

Серверная часть:

Backend Framework: NestJS (Node.js + TypeScript) – модульный, поддерживает инъекцию зависимостей, имеет интеграцию с WebSockets, а также можно реализовать RPC-шлюз. Мы планируем реализовать API двумя способами:

REST API для стандартных запросов (создать чек, получить список товаров и т.д.).

tRPC-подобный (или GraphQL) для типобезопасного общения Web Admin → Backend. Возможно, Next.js (App Router) будет вызывать серверные действия (route handlers) напрямую на том же хосте.

База данных (OLTP): PostgreSQL, как надёжное хранилище для основной бизнес-информации. Структура данных спроектирована с учётом multi-tenant (tenant_id в нужных таблицах + RLS политик).

Миграции: управляются с помощью Prisma Migrate или dbmate. Храним схему в Git, миграции версионные.

ORM: Prisma позволит типобезопасно работать с БД. Также можно использовать Prisma для генерации типов, которые затем валидировать Zod'ом.

Взаимодействие POS с сервером: POS может напрямую обращаться к API (REST) при наличии интернета. Но для оффлайна – POS может накапливать операции.

Когда интернет появляется, POS шлёт пачку запросов или один batched request. Можно реализовать sync-эндпоинт, который принимает список изменений (продажи, новые клиенты и т.д.).

Сервер обрабатывает каждую операцию идемпотентно (повторная отправка того же чека не создаст дубликат, API использует уникальные идентификаторы, генерируемые на клиенте, например UUID для чеков).

Ответом сервер может прислать и обновления (например, «у тебя версия справочника устарела, вот новые данные» или подтверждение синхронизации).

Очереди и фоновые задачи:

Используем Redis для простых очередей и кэша. Например, очередь на отправку фискальных команд: Backend кладёт задачу в Redis, fiscal-gateway (отдельный сервис) её забирает.

Redis также пригодится для кэширования часто запрашиваемых данных (справочники, настройки) чтобы разгрузить Postgres.

NATS (опционально): если решим построить событийную архитектуру, NATS Streaming (или Kafka, но Kafka тяжеловеснее) будет брокером. Можно отправлять событие "sale.created" и на него подпишется модуль лояльности, модуль отчетов, и т.д. Пока это не строго необходимо, но возможно при внедрении ClickHouse через Debezium Kafka станет фактом.

Сервис фискализации (fiscal-gateway): Выделен отдельный микросервис, написанный, например, на C# или Go (или даже NodeJS, если найдутся SDK) – его задача: работать с драйверами ККМ.

Интерфейс fiscal-gateway — HTTP API или RPC. Например, POST /openShift с данными магазина, возвращает { success, shiftNumber,… } или ошибку.

Обработка сложных случаев (принтер не отвечает, бумаги нет) – fiscal-gateway должен сигнализировать обратно. POS/Backend должны это обрабатывать и отображать оператору.

fiscal-gateway изолирует все локальные тонкости фискальных регистраторов. Его можно установить локально (рядом с POS) или запускать централизованно (если используется облачная фискализация). В Узбекистане, скорее всего, ККМ подключаются к локальному компу, значит fiscal-gateway либо встроен в POS-клиент, либо работает как Windows-служба.

Логи и мониторинг:

Внедряем OpenTelemetry SDK в бекенд и в POS (через Electron main process) для сбора трасс (trace) – например, последовательность действий при синхронизации.

Разворачиваем стек наблюдаемости: Grafana для метрик (можно Prometheus подключить), Loki для логов, Tempo для трейсинга. Это важно для быстрого отладки проблем в продакшене.

Ошибки фронтенда: В веб и POS можно подключить Sentry или аналоги, чтобы ловить исключения UI.

Безопасность:

Все внешние соединения должны быть по HTTPS (SSL).

Хранение секретов (например, ключи API интеграций) в защищённом виде (HashiCorp Vault или хотя бы .env на сервере).

Защита от SQL-инъекций, XSS – обеспечивается использованием ORM и тщательно эскейпя пользовательский ввод при выводе.

Rate limiting на публичные API (например, на попытки логина).

JWT токены шифруются, могут иметь ограниченный срок действия (refresh tokens).

Аналитическая подсистема:

Debezium + Kafka: Debezium коннектор читает WAL логи Postgres, и публикует события (insert/update/delete) в топики Kafka. Интересующиеся сервисы (например, коннектор ClickHouse) читают эти события.

ClickHouse: Разворачивается БД ClickHouse, настроены таблицы под нужные отчёты (например, таблица фактов продаж с нужными агрегатами). Используем Materialized Views для агрегированных показателей (продажи по дням, топ товаров) чтобы отчёты были мгновенными.

Отчётный API: Backend, получая запрос на отчёт, либо:

A) идёт в Postgres (для небольших выборок, например, остатки на текущий момент),

B) или идёт в ClickHouse (для масштабных, типа продажи за год по дням).

Это можно скрыть за Repo слоем – запросы определяются в зависимости от объёма/типа отчёта.

План Б без ClickHouse: Если MVP нужно срочно, можно без сложной аналитики – Postgres справится с первыми клиентами. Но архитектуру описали с прицелом на рост.

Масштабирование:

Приложение stateless (NestJS) – может масштабироваться горизонтально (несколько инстансов за load balancer’ом) для обслуживания большего числа пользователей.

Postgres – можно настроить реплики для чтения, шардинг по tenant (если очень вырастет база, но на старте не нужно).

Отделение сервисов: Фискальный сервис отдельно, может несколько инстансов для разных регионов.

Обработка очередей – отдельно, чтобы тяжелые задачи (например, генерация отчёта PDF) не тормозили основные запросы.

DevOps:

Контейнеризация: Все компоненты (NestJS, ClickHouse, Redis, etc.) можно упаковать в Docker. Деплой в облако (например, AWS, Azure, либо локальный сервер).

CI/CD: Настроить pipeline для автоматического тестирования и деплоя (например, GitHub Actions → build Docker → push).

Backups: Регулярный бэкап базы (и сохранение на внешний storage).

Учет версий API: если будем развивать API, следить за версионностью, чтобы не поломать совместимость с уже установленными POS-клиентами (POS может обновляться автоматом, но всё же).

Производительность:

Целевые показатели: время отклика основных API < 200мс, время синхронизации чека – пару секунд макс (в оффлайне не влияет на кассира, но при онлайн стараемся быстро).

POS должен работать на обычном офисном ПК (Windows 10+, 4GB RAM) без лагов.

Тестировать на больших данных: каталог 100k товаров, 1 млн продаж – интерфейсы должны выдерживать (виртуализированные списки, постраничные загрузки).

Observability (Наблюдаемость):

Логирование действий: Пишем инфо-логи при ключевых событиях (открытие смены, ошибка синхронизации, запрос к внешнему API и т.д.) – чтобы потом можно было диагностировать.

Метрики: Собираем метрики по количеству чеков в час, среднему времени транзакции, памяти, CPU – для оптимизации.

Audit log неизменяемый: Как говорилось, критичные данные (финансы) – записываются в отдельную таблицу, где UPDATE/DELETE запрещены, только INSERT. Это наш «след операций», который можно использовать для разборов инцидентов и доверия.

(Архитектура обеспечивает основу для всех перечисленных в требованиях возможностей, с упором на масштабируемость и надёжность.)